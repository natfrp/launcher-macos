//
// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the protocol buffer compiler.
// Source: grpc_service.proto
//
import GRPC
import NIO
import NIOConcurrencyHelpers
import SwiftProtobuf


/// Usage: instantiate `NatfrpServiceClient`, then call methods of this protocol to make API calls.
internal protocol NatfrpServiceClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: NatfrpServiceClientInterceptorFactoryProtocol? { get }

  func streamLog(
    _ request: Empty,
    callOptions: CallOptions?,
    handler: @escaping (Log) -> Void
  ) -> ServerStreamingCall<Empty, Log>

  func streamTunnels(
    _ request: Empty,
    callOptions: CallOptions?,
    handler: @escaping (TunnelUpdate) -> Void
  ) -> ServerStreamingCall<Empty, TunnelUpdate>

  func streamUpdate(
    _ request: Empty,
    callOptions: CallOptions?,
    handler: @escaping (StateUpdate) -> Void
  ) -> ServerStreamingCall<Empty, StateUpdate>

  func streamStats(
    _ request: Empty,
    callOptions: CallOptions?,
    handler: @escaping (StatsUpdate) -> Void
  ) -> ServerStreamingCall<Empty, StatsUpdate>

  func login(
    _ request: LoginRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<LoginRequest, Empty>

  func logout(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> UnaryCall<Empty, Empty>

  func updateTunnel(
    _ request: TunnelUpdate,
    callOptions: CallOptions?
  ) -> UnaryCall<TunnelUpdate, TunnelUpdate>

  func reloadTunnels(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> UnaryCall<Empty, Empty>

  func reloadNodes(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> UnaryCall<Empty, Empty>

  func clearLog(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> UnaryCall<Empty, Empty>

  func shutdown(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> UnaryCall<Empty, Empty>

  func checkUpdate(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> UnaryCall<Empty, SoftwareUpdate>

  func confirmUpdate(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> UnaryCall<Empty, Empty>

  func updateConfig(
    _ request: ServiceConfig,
    callOptions: CallOptions?
  ) -> UnaryCall<ServiceConfig, Empty>

  func openCWD(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> UnaryCall<Empty, Empty>
}

extension NatfrpServiceClientProtocol {
  internal var serviceName: String {
    return "NatfrpService"
  }

  /// Sends current log buffer on connect, then append log on arrival.
  ///
  /// - Parameters:
  ///   - request: Request to send to StreamLog.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func streamLog(
    _ request: Empty,
    callOptions: CallOptions? = nil,
    handler: @escaping (Log) -> Void
  ) -> ServerStreamingCall<Empty, Log> {
    return self.makeServerStreamingCall(
      path: NatfrpServiceClientMetadata.Methods.streamLog.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamLogInterceptors() ?? [],
      handler: handler
    )
  }

  /// Sends all tunnels on connect, then send diff on change.
  ///
  /// - Parameters:
  ///   - request: Request to send to StreamTunnels.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func streamTunnels(
    _ request: Empty,
    callOptions: CallOptions? = nil,
    handler: @escaping (TunnelUpdate) -> Void
  ) -> ServerStreamingCall<Empty, TunnelUpdate> {
    return self.makeServerStreamingCall(
      path: NatfrpServiceClientMetadata.Methods.streamTunnels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamTunnelsInterceptors() ?? [],
      handler: handler
    )
  }

  /// Sends User, Nodes, Config, SoftwareUpdate on connect, then send updated
  /// entry on change.
  ///
  /// - Parameters:
  ///   - request: Request to send to StreamUpdate.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func streamUpdate(
    _ request: Empty,
    callOptions: CallOptions? = nil,
    handler: @escaping (StateUpdate) -> Void
  ) -> ServerStreamingCall<Empty, StateUpdate> {
    return self.makeServerStreamingCall(
      path: NatfrpServiceClientMetadata.Methods.streamUpdate.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamUpdateInterceptors() ?? [],
      handler: handler
    )
  }

  /// Sends current stats buffer on connect, then append each second.
  ///
  /// - Parameters:
  ///   - request: Request to send to StreamStats.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func streamStats(
    _ request: Empty,
    callOptions: CallOptions? = nil,
    handler: @escaping (StatsUpdate) -> Void
  ) -> ServerStreamingCall<Empty, StatsUpdate> {
    return self.makeServerStreamingCall(
      path: NatfrpServiceClientMetadata.Methods.streamStats.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamStatsInterceptors() ?? [],
      handler: handler
    )
  }

  /// Unary call to Login
  ///
  /// - Parameters:
  ///   - request: Request to send to Login.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func login(
    _ request: LoginRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<LoginRequest, Empty> {
    return self.makeUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.login.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLoginInterceptors() ?? []
    )
  }

  /// Unary call to Logout
  ///
  /// - Parameters:
  ///   - request: Request to send to Logout.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func logout(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Empty, Empty> {
    return self.makeUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.logout.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLogoutInterceptors() ?? []
    )
  }

  /// For Add, returns created tunnel.
  /// For Delete, Update, return empty data.
  ///
  /// - Parameters:
  ///   - request: Request to send to UpdateTunnel.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func updateTunnel(
    _ request: TunnelUpdate,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<TunnelUpdate, TunnelUpdate> {
    return self.makeUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.updateTunnel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUpdateTunnelInterceptors() ?? []
    )
  }

  /// Unary call to ReloadTunnels
  ///
  /// - Parameters:
  ///   - request: Request to send to ReloadTunnels.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func reloadTunnels(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Empty, Empty> {
    return self.makeUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.reloadTunnels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeReloadTunnelsInterceptors() ?? []
    )
  }

  /// Unary call to ReloadNodes
  ///
  /// - Parameters:
  ///   - request: Request to send to ReloadNodes.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func reloadNodes(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Empty, Empty> {
    return self.makeUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.reloadNodes.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeReloadNodesInterceptors() ?? []
    )
  }

  /// Unary call to ClearLog
  ///
  /// - Parameters:
  ///   - request: Request to send to ClearLog.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func clearLog(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Empty, Empty> {
    return self.makeUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.clearLog.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeClearLogInterceptors() ?? []
    )
  }

  /// Unary call to Shutdown
  ///
  /// - Parameters:
  ///   - request: Request to send to Shutdown.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func shutdown(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Empty, Empty> {
    return self.makeUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.shutdown.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeShutdownInterceptors() ?? []
    )
  }

  /// Unary call to CheckUpdate
  ///
  /// - Parameters:
  ///   - request: Request to send to CheckUpdate.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func checkUpdate(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Empty, SoftwareUpdate> {
    return self.makeUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.checkUpdate.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCheckUpdateInterceptors() ?? []
    )
  }

  /// Unary call to ConfirmUpdate
  ///
  /// - Parameters:
  ///   - request: Request to send to ConfirmUpdate.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func confirmUpdate(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Empty, Empty> {
    return self.makeUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.confirmUpdate.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeConfirmUpdateInterceptors() ?? []
    )
  }

  /// Unary call to UpdateConfig
  ///
  /// - Parameters:
  ///   - request: Request to send to UpdateConfig.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func updateConfig(
    _ request: ServiceConfig,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<ServiceConfig, Empty> {
    return self.makeUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.updateConfig.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUpdateConfigInterceptors() ?? []
    )
  }

  /// Unary call to OpenCWD
  ///
  /// - Parameters:
  ///   - request: Request to send to OpenCWD.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func openCWD(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Empty, Empty> {
    return self.makeUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.openCWD.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenCWDInterceptors() ?? []
    )
  }
}

@available(*, deprecated)
extension NatfrpServiceClient: @unchecked Sendable {}

@available(*, deprecated, renamed: "NatfrpServiceNIOClient")
internal final class NatfrpServiceClient: NatfrpServiceClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: NatfrpServiceClientInterceptorFactoryProtocol?
  internal let channel: GRPCChannel
  internal var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  internal var interceptors: NatfrpServiceClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the NatfrpService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: NatfrpServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

internal struct NatfrpServiceNIOClient: NatfrpServiceClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: NatfrpServiceClientInterceptorFactoryProtocol?

  /// Creates a client for the NatfrpService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: NatfrpServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol NatfrpServiceAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: NatfrpServiceClientInterceptorFactoryProtocol? { get }

  func makeStreamLogCall(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Empty, Log>

  func makeStreamTunnelsCall(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Empty, TunnelUpdate>

  func makeStreamUpdateCall(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Empty, StateUpdate>

  func makeStreamStatsCall(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Empty, StatsUpdate>

  func makeLoginCall(
    _ request: LoginRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<LoginRequest, Empty>

  func makeLogoutCall(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Empty, Empty>

  func makeUpdateTunnelCall(
    _ request: TunnelUpdate,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<TunnelUpdate, TunnelUpdate>

  func makeReloadTunnelsCall(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Empty, Empty>

  func makeReloadNodesCall(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Empty, Empty>

  func makeClearLogCall(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Empty, Empty>

  func makeShutdownCall(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Empty, Empty>

  func makeCheckUpdateCall(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Empty, SoftwareUpdate>

  func makeConfirmUpdateCall(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Empty, Empty>

  func makeUpdateConfigCall(
    _ request: ServiceConfig,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<ServiceConfig, Empty>

  func makeOpenCwdCall(
    _ request: Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Empty, Empty>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NatfrpServiceAsyncClientProtocol {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return NatfrpServiceClientMetadata.serviceDescriptor
  }

  internal var interceptors: NatfrpServiceClientInterceptorFactoryProtocol? {
    return nil
  }

  internal func makeStreamLogCall(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Empty, Log> {
    return self.makeAsyncServerStreamingCall(
      path: NatfrpServiceClientMetadata.Methods.streamLog.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamLogInterceptors() ?? []
    )
  }

  internal func makeStreamTunnelsCall(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Empty, TunnelUpdate> {
    return self.makeAsyncServerStreamingCall(
      path: NatfrpServiceClientMetadata.Methods.streamTunnels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamTunnelsInterceptors() ?? []
    )
  }

  internal func makeStreamUpdateCall(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Empty, StateUpdate> {
    return self.makeAsyncServerStreamingCall(
      path: NatfrpServiceClientMetadata.Methods.streamUpdate.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamUpdateInterceptors() ?? []
    )
  }

  internal func makeStreamStatsCall(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Empty, StatsUpdate> {
    return self.makeAsyncServerStreamingCall(
      path: NatfrpServiceClientMetadata.Methods.streamStats.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamStatsInterceptors() ?? []
    )
  }

  internal func makeLoginCall(
    _ request: LoginRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<LoginRequest, Empty> {
    return self.makeAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.login.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLoginInterceptors() ?? []
    )
  }

  internal func makeLogoutCall(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Empty, Empty> {
    return self.makeAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.logout.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLogoutInterceptors() ?? []
    )
  }

  internal func makeUpdateTunnelCall(
    _ request: TunnelUpdate,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<TunnelUpdate, TunnelUpdate> {
    return self.makeAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.updateTunnel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUpdateTunnelInterceptors() ?? []
    )
  }

  internal func makeReloadTunnelsCall(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Empty, Empty> {
    return self.makeAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.reloadTunnels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeReloadTunnelsInterceptors() ?? []
    )
  }

  internal func makeReloadNodesCall(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Empty, Empty> {
    return self.makeAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.reloadNodes.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeReloadNodesInterceptors() ?? []
    )
  }

  internal func makeClearLogCall(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Empty, Empty> {
    return self.makeAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.clearLog.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeClearLogInterceptors() ?? []
    )
  }

  internal func makeShutdownCall(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Empty, Empty> {
    return self.makeAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.shutdown.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeShutdownInterceptors() ?? []
    )
  }

  internal func makeCheckUpdateCall(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Empty, SoftwareUpdate> {
    return self.makeAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.checkUpdate.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCheckUpdateInterceptors() ?? []
    )
  }

  internal func makeConfirmUpdateCall(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Empty, Empty> {
    return self.makeAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.confirmUpdate.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeConfirmUpdateInterceptors() ?? []
    )
  }

  internal func makeUpdateConfigCall(
    _ request: ServiceConfig,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<ServiceConfig, Empty> {
    return self.makeAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.updateConfig.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUpdateConfigInterceptors() ?? []
    )
  }

  internal func makeOpenCwdCall(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Empty, Empty> {
    return self.makeAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.openCWD.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenCWDInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NatfrpServiceAsyncClientProtocol {
  internal func streamLog(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Log> {
    return self.performAsyncServerStreamingCall(
      path: NatfrpServiceClientMetadata.Methods.streamLog.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamLogInterceptors() ?? []
    )
  }

  internal func streamTunnels(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<TunnelUpdate> {
    return self.performAsyncServerStreamingCall(
      path: NatfrpServiceClientMetadata.Methods.streamTunnels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamTunnelsInterceptors() ?? []
    )
  }

  internal func streamUpdate(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<StateUpdate> {
    return self.performAsyncServerStreamingCall(
      path: NatfrpServiceClientMetadata.Methods.streamUpdate.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamUpdateInterceptors() ?? []
    )
  }

  internal func streamStats(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<StatsUpdate> {
    return self.performAsyncServerStreamingCall(
      path: NatfrpServiceClientMetadata.Methods.streamStats.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStreamStatsInterceptors() ?? []
    )
  }

  internal func login(
    _ request: LoginRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Empty {
    return try await self.performAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.login.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLoginInterceptors() ?? []
    )
  }

  internal func logout(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) async throws -> Empty {
    return try await self.performAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.logout.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLogoutInterceptors() ?? []
    )
  }

  internal func updateTunnel(
    _ request: TunnelUpdate,
    callOptions: CallOptions? = nil
  ) async throws -> TunnelUpdate {
    return try await self.performAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.updateTunnel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUpdateTunnelInterceptors() ?? []
    )
  }

  internal func reloadTunnels(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) async throws -> Empty {
    return try await self.performAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.reloadTunnels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeReloadTunnelsInterceptors() ?? []
    )
  }

  internal func reloadNodes(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) async throws -> Empty {
    return try await self.performAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.reloadNodes.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeReloadNodesInterceptors() ?? []
    )
  }

  internal func clearLog(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) async throws -> Empty {
    return try await self.performAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.clearLog.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeClearLogInterceptors() ?? []
    )
  }

  internal func shutdown(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) async throws -> Empty {
    return try await self.performAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.shutdown.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeShutdownInterceptors() ?? []
    )
  }

  internal func checkUpdate(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) async throws -> SoftwareUpdate {
    return try await self.performAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.checkUpdate.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCheckUpdateInterceptors() ?? []
    )
  }

  internal func confirmUpdate(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) async throws -> Empty {
    return try await self.performAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.confirmUpdate.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeConfirmUpdateInterceptors() ?? []
    )
  }

  internal func updateConfig(
    _ request: ServiceConfig,
    callOptions: CallOptions? = nil
  ) async throws -> Empty {
    return try await self.performAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.updateConfig.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUpdateConfigInterceptors() ?? []
    )
  }

  internal func openCWD(
    _ request: Empty,
    callOptions: CallOptions? = nil
  ) async throws -> Empty {
    return try await self.performAsyncUnaryCall(
      path: NatfrpServiceClientMetadata.Methods.openCWD.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenCWDInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal struct NatfrpServiceAsyncClient: NatfrpServiceAsyncClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: NatfrpServiceClientInterceptorFactoryProtocol?

  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: NatfrpServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

internal protocol NatfrpServiceClientInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when invoking 'streamLog'.
  func makeStreamLogInterceptors() -> [ClientInterceptor<Empty, Log>]

  /// - Returns: Interceptors to use when invoking 'streamTunnels'.
  func makeStreamTunnelsInterceptors() -> [ClientInterceptor<Empty, TunnelUpdate>]

  /// - Returns: Interceptors to use when invoking 'streamUpdate'.
  func makeStreamUpdateInterceptors() -> [ClientInterceptor<Empty, StateUpdate>]

  /// - Returns: Interceptors to use when invoking 'streamStats'.
  func makeStreamStatsInterceptors() -> [ClientInterceptor<Empty, StatsUpdate>]

  /// - Returns: Interceptors to use when invoking 'login'.
  func makeLoginInterceptors() -> [ClientInterceptor<LoginRequest, Empty>]

  /// - Returns: Interceptors to use when invoking 'logout'.
  func makeLogoutInterceptors() -> [ClientInterceptor<Empty, Empty>]

  /// - Returns: Interceptors to use when invoking 'updateTunnel'.
  func makeUpdateTunnelInterceptors() -> [ClientInterceptor<TunnelUpdate, TunnelUpdate>]

  /// - Returns: Interceptors to use when invoking 'reloadTunnels'.
  func makeReloadTunnelsInterceptors() -> [ClientInterceptor<Empty, Empty>]

  /// - Returns: Interceptors to use when invoking 'reloadNodes'.
  func makeReloadNodesInterceptors() -> [ClientInterceptor<Empty, Empty>]

  /// - Returns: Interceptors to use when invoking 'clearLog'.
  func makeClearLogInterceptors() -> [ClientInterceptor<Empty, Empty>]

  /// - Returns: Interceptors to use when invoking 'shutdown'.
  func makeShutdownInterceptors() -> [ClientInterceptor<Empty, Empty>]

  /// - Returns: Interceptors to use when invoking 'checkUpdate'.
  func makeCheckUpdateInterceptors() -> [ClientInterceptor<Empty, SoftwareUpdate>]

  /// - Returns: Interceptors to use when invoking 'confirmUpdate'.
  func makeConfirmUpdateInterceptors() -> [ClientInterceptor<Empty, Empty>]

  /// - Returns: Interceptors to use when invoking 'updateConfig'.
  func makeUpdateConfigInterceptors() -> [ClientInterceptor<ServiceConfig, Empty>]

  /// - Returns: Interceptors to use when invoking 'openCWD'.
  func makeOpenCWDInterceptors() -> [ClientInterceptor<Empty, Empty>]
}

internal enum NatfrpServiceClientMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "NatfrpService",
    fullName: "NatfrpService",
    methods: [
      NatfrpServiceClientMetadata.Methods.streamLog,
      NatfrpServiceClientMetadata.Methods.streamTunnels,
      NatfrpServiceClientMetadata.Methods.streamUpdate,
      NatfrpServiceClientMetadata.Methods.streamStats,
      NatfrpServiceClientMetadata.Methods.login,
      NatfrpServiceClientMetadata.Methods.logout,
      NatfrpServiceClientMetadata.Methods.updateTunnel,
      NatfrpServiceClientMetadata.Methods.reloadTunnels,
      NatfrpServiceClientMetadata.Methods.reloadNodes,
      NatfrpServiceClientMetadata.Methods.clearLog,
      NatfrpServiceClientMetadata.Methods.shutdown,
      NatfrpServiceClientMetadata.Methods.checkUpdate,
      NatfrpServiceClientMetadata.Methods.confirmUpdate,
      NatfrpServiceClientMetadata.Methods.updateConfig,
      NatfrpServiceClientMetadata.Methods.openCWD,
    ]
  )

  internal enum Methods {
    internal static let streamLog = GRPCMethodDescriptor(
      name: "StreamLog",
      path: "/NatfrpService/StreamLog",
      type: GRPCCallType.serverStreaming
    )

    internal static let streamTunnels = GRPCMethodDescriptor(
      name: "StreamTunnels",
      path: "/NatfrpService/StreamTunnels",
      type: GRPCCallType.serverStreaming
    )

    internal static let streamUpdate = GRPCMethodDescriptor(
      name: "StreamUpdate",
      path: "/NatfrpService/StreamUpdate",
      type: GRPCCallType.serverStreaming
    )

    internal static let streamStats = GRPCMethodDescriptor(
      name: "StreamStats",
      path: "/NatfrpService/StreamStats",
      type: GRPCCallType.serverStreaming
    )

    internal static let login = GRPCMethodDescriptor(
      name: "Login",
      path: "/NatfrpService/Login",
      type: GRPCCallType.unary
    )

    internal static let logout = GRPCMethodDescriptor(
      name: "Logout",
      path: "/NatfrpService/Logout",
      type: GRPCCallType.unary
    )

    internal static let updateTunnel = GRPCMethodDescriptor(
      name: "UpdateTunnel",
      path: "/NatfrpService/UpdateTunnel",
      type: GRPCCallType.unary
    )

    internal static let reloadTunnels = GRPCMethodDescriptor(
      name: "ReloadTunnels",
      path: "/NatfrpService/ReloadTunnels",
      type: GRPCCallType.unary
    )

    internal static let reloadNodes = GRPCMethodDescriptor(
      name: "ReloadNodes",
      path: "/NatfrpService/ReloadNodes",
      type: GRPCCallType.unary
    )

    internal static let clearLog = GRPCMethodDescriptor(
      name: "ClearLog",
      path: "/NatfrpService/ClearLog",
      type: GRPCCallType.unary
    )

    internal static let shutdown = GRPCMethodDescriptor(
      name: "Shutdown",
      path: "/NatfrpService/Shutdown",
      type: GRPCCallType.unary
    )

    internal static let checkUpdate = GRPCMethodDescriptor(
      name: "CheckUpdate",
      path: "/NatfrpService/CheckUpdate",
      type: GRPCCallType.unary
    )

    internal static let confirmUpdate = GRPCMethodDescriptor(
      name: "ConfirmUpdate",
      path: "/NatfrpService/ConfirmUpdate",
      type: GRPCCallType.unary
    )

    internal static let updateConfig = GRPCMethodDescriptor(
      name: "UpdateConfig",
      path: "/NatfrpService/UpdateConfig",
      type: GRPCCallType.unary
    )

    internal static let openCWD = GRPCMethodDescriptor(
      name: "OpenCWD",
      path: "/NatfrpService/OpenCWD",
      type: GRPCCallType.unary
    )
  }
}

/// To build a server, implement a class that conforms to this protocol.
internal protocol NatfrpServiceProvider: CallHandlerProvider {
  var interceptors: NatfrpServiceServerInterceptorFactoryProtocol? { get }

  /// Sends current log buffer on connect, then append log on arrival.
  func streamLog(request: Empty, context: StreamingResponseCallContext<Log>) -> EventLoopFuture<GRPCStatus>

  /// Sends all tunnels on connect, then send diff on change.
  func streamTunnels(request: Empty, context: StreamingResponseCallContext<TunnelUpdate>) -> EventLoopFuture<GRPCStatus>

  /// Sends User, Nodes, Config, SoftwareUpdate on connect, then send updated
  /// entry on change.
  func streamUpdate(request: Empty, context: StreamingResponseCallContext<StateUpdate>) -> EventLoopFuture<GRPCStatus>

  /// Sends current stats buffer on connect, then append each second.
  func streamStats(request: Empty, context: StreamingResponseCallContext<StatsUpdate>) -> EventLoopFuture<GRPCStatus>

  func login(request: LoginRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Empty>

  func logout(request: Empty, context: StatusOnlyCallContext) -> EventLoopFuture<Empty>

  /// For Add, returns created tunnel.
  /// For Delete, Update, return empty data.
  func updateTunnel(request: TunnelUpdate, context: StatusOnlyCallContext) -> EventLoopFuture<TunnelUpdate>

  func reloadTunnels(request: Empty, context: StatusOnlyCallContext) -> EventLoopFuture<Empty>

  func reloadNodes(request: Empty, context: StatusOnlyCallContext) -> EventLoopFuture<Empty>

  func clearLog(request: Empty, context: StatusOnlyCallContext) -> EventLoopFuture<Empty>

  func shutdown(request: Empty, context: StatusOnlyCallContext) -> EventLoopFuture<Empty>

  func checkUpdate(request: Empty, context: StatusOnlyCallContext) -> EventLoopFuture<SoftwareUpdate>

  func confirmUpdate(request: Empty, context: StatusOnlyCallContext) -> EventLoopFuture<Empty>

  func updateConfig(request: ServiceConfig, context: StatusOnlyCallContext) -> EventLoopFuture<Empty>

  func openCWD(request: Empty, context: StatusOnlyCallContext) -> EventLoopFuture<Empty>
}

extension NatfrpServiceProvider {
  internal var serviceName: Substring {
    return NatfrpServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "StreamLog":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Log>(),
        interceptors: self.interceptors?.makeStreamLogInterceptors() ?? [],
        userFunction: self.streamLog(request:context:)
      )

    case "StreamTunnels":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<TunnelUpdate>(),
        interceptors: self.interceptors?.makeStreamTunnelsInterceptors() ?? [],
        userFunction: self.streamTunnels(request:context:)
      )

    case "StreamUpdate":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<StateUpdate>(),
        interceptors: self.interceptors?.makeStreamUpdateInterceptors() ?? [],
        userFunction: self.streamUpdate(request:context:)
      )

    case "StreamStats":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<StatsUpdate>(),
        interceptors: self.interceptors?.makeStreamStatsInterceptors() ?? [],
        userFunction: self.streamStats(request:context:)
      )

    case "Login":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<LoginRequest>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeLoginInterceptors() ?? [],
        userFunction: self.login(request:context:)
      )

    case "Logout":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeLogoutInterceptors() ?? [],
        userFunction: self.logout(request:context:)
      )

    case "UpdateTunnel":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<TunnelUpdate>(),
        responseSerializer: ProtobufSerializer<TunnelUpdate>(),
        interceptors: self.interceptors?.makeUpdateTunnelInterceptors() ?? [],
        userFunction: self.updateTunnel(request:context:)
      )

    case "ReloadTunnels":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeReloadTunnelsInterceptors() ?? [],
        userFunction: self.reloadTunnels(request:context:)
      )

    case "ReloadNodes":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeReloadNodesInterceptors() ?? [],
        userFunction: self.reloadNodes(request:context:)
      )

    case "ClearLog":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeClearLogInterceptors() ?? [],
        userFunction: self.clearLog(request:context:)
      )

    case "Shutdown":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeShutdownInterceptors() ?? [],
        userFunction: self.shutdown(request:context:)
      )

    case "CheckUpdate":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<SoftwareUpdate>(),
        interceptors: self.interceptors?.makeCheckUpdateInterceptors() ?? [],
        userFunction: self.checkUpdate(request:context:)
      )

    case "ConfirmUpdate":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeConfirmUpdateInterceptors() ?? [],
        userFunction: self.confirmUpdate(request:context:)
      )

    case "UpdateConfig":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<ServiceConfig>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeUpdateConfigInterceptors() ?? [],
        userFunction: self.updateConfig(request:context:)
      )

    case "OpenCWD":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeOpenCWDInterceptors() ?? [],
        userFunction: self.openCWD(request:context:)
      )

    default:
      return nil
    }
  }
}

/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol NatfrpServiceAsyncProvider: CallHandlerProvider, Sendable {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: NatfrpServiceServerInterceptorFactoryProtocol? { get }

  /// Sends current log buffer on connect, then append log on arrival.
  func streamLog(
    request: Empty,
    responseStream: GRPCAsyncResponseStreamWriter<Log>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// Sends all tunnels on connect, then send diff on change.
  func streamTunnels(
    request: Empty,
    responseStream: GRPCAsyncResponseStreamWriter<TunnelUpdate>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// Sends User, Nodes, Config, SoftwareUpdate on connect, then send updated
  /// entry on change.
  func streamUpdate(
    request: Empty,
    responseStream: GRPCAsyncResponseStreamWriter<StateUpdate>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// Sends current stats buffer on connect, then append each second.
  func streamStats(
    request: Empty,
    responseStream: GRPCAsyncResponseStreamWriter<StatsUpdate>,
    context: GRPCAsyncServerCallContext
  ) async throws

  func login(
    request: LoginRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Empty

  func logout(
    request: Empty,
    context: GRPCAsyncServerCallContext
  ) async throws -> Empty

  /// For Add, returns created tunnel.
  /// For Delete, Update, return empty data.
  func updateTunnel(
    request: TunnelUpdate,
    context: GRPCAsyncServerCallContext
  ) async throws -> TunnelUpdate

  func reloadTunnels(
    request: Empty,
    context: GRPCAsyncServerCallContext
  ) async throws -> Empty

  func reloadNodes(
    request: Empty,
    context: GRPCAsyncServerCallContext
  ) async throws -> Empty

  func clearLog(
    request: Empty,
    context: GRPCAsyncServerCallContext
  ) async throws -> Empty

  func shutdown(
    request: Empty,
    context: GRPCAsyncServerCallContext
  ) async throws -> Empty

  func checkUpdate(
    request: Empty,
    context: GRPCAsyncServerCallContext
  ) async throws -> SoftwareUpdate

  func confirmUpdate(
    request: Empty,
    context: GRPCAsyncServerCallContext
  ) async throws -> Empty

  func updateConfig(
    request: ServiceConfig,
    context: GRPCAsyncServerCallContext
  ) async throws -> Empty

  func openCWD(
    request: Empty,
    context: GRPCAsyncServerCallContext
  ) async throws -> Empty
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NatfrpServiceAsyncProvider {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return NatfrpServiceServerMetadata.serviceDescriptor
  }

  internal var serviceName: Substring {
    return NatfrpServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  internal var interceptors: NatfrpServiceServerInterceptorFactoryProtocol? {
    return nil
  }

  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "StreamLog":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Log>(),
        interceptors: self.interceptors?.makeStreamLogInterceptors() ?? [],
        wrapping: { try await self.streamLog(request: $0, responseStream: $1, context: $2) }
      )

    case "StreamTunnels":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<TunnelUpdate>(),
        interceptors: self.interceptors?.makeStreamTunnelsInterceptors() ?? [],
        wrapping: { try await self.streamTunnels(request: $0, responseStream: $1, context: $2) }
      )

    case "StreamUpdate":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<StateUpdate>(),
        interceptors: self.interceptors?.makeStreamUpdateInterceptors() ?? [],
        wrapping: { try await self.streamUpdate(request: $0, responseStream: $1, context: $2) }
      )

    case "StreamStats":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<StatsUpdate>(),
        interceptors: self.interceptors?.makeStreamStatsInterceptors() ?? [],
        wrapping: { try await self.streamStats(request: $0, responseStream: $1, context: $2) }
      )

    case "Login":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<LoginRequest>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeLoginInterceptors() ?? [],
        wrapping: { try await self.login(request: $0, context: $1) }
      )

    case "Logout":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeLogoutInterceptors() ?? [],
        wrapping: { try await self.logout(request: $0, context: $1) }
      )

    case "UpdateTunnel":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<TunnelUpdate>(),
        responseSerializer: ProtobufSerializer<TunnelUpdate>(),
        interceptors: self.interceptors?.makeUpdateTunnelInterceptors() ?? [],
        wrapping: { try await self.updateTunnel(request: $0, context: $1) }
      )

    case "ReloadTunnels":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeReloadTunnelsInterceptors() ?? [],
        wrapping: { try await self.reloadTunnels(request: $0, context: $1) }
      )

    case "ReloadNodes":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeReloadNodesInterceptors() ?? [],
        wrapping: { try await self.reloadNodes(request: $0, context: $1) }
      )

    case "ClearLog":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeClearLogInterceptors() ?? [],
        wrapping: { try await self.clearLog(request: $0, context: $1) }
      )

    case "Shutdown":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeShutdownInterceptors() ?? [],
        wrapping: { try await self.shutdown(request: $0, context: $1) }
      )

    case "CheckUpdate":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<SoftwareUpdate>(),
        interceptors: self.interceptors?.makeCheckUpdateInterceptors() ?? [],
        wrapping: { try await self.checkUpdate(request: $0, context: $1) }
      )

    case "ConfirmUpdate":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeConfirmUpdateInterceptors() ?? [],
        wrapping: { try await self.confirmUpdate(request: $0, context: $1) }
      )

    case "UpdateConfig":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<ServiceConfig>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeUpdateConfigInterceptors() ?? [],
        wrapping: { try await self.updateConfig(request: $0, context: $1) }
      )

    case "OpenCWD":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Empty>(),
        responseSerializer: ProtobufSerializer<Empty>(),
        interceptors: self.interceptors?.makeOpenCWDInterceptors() ?? [],
        wrapping: { try await self.openCWD(request: $0, context: $1) }
      )

    default:
      return nil
    }
  }
}

internal protocol NatfrpServiceServerInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when handling 'streamLog'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStreamLogInterceptors() -> [ServerInterceptor<Empty, Log>]

  /// - Returns: Interceptors to use when handling 'streamTunnels'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStreamTunnelsInterceptors() -> [ServerInterceptor<Empty, TunnelUpdate>]

  /// - Returns: Interceptors to use when handling 'streamUpdate'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStreamUpdateInterceptors() -> [ServerInterceptor<Empty, StateUpdate>]

  /// - Returns: Interceptors to use when handling 'streamStats'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStreamStatsInterceptors() -> [ServerInterceptor<Empty, StatsUpdate>]

  /// - Returns: Interceptors to use when handling 'login'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeLoginInterceptors() -> [ServerInterceptor<LoginRequest, Empty>]

  /// - Returns: Interceptors to use when handling 'logout'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeLogoutInterceptors() -> [ServerInterceptor<Empty, Empty>]

  /// - Returns: Interceptors to use when handling 'updateTunnel'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeUpdateTunnelInterceptors() -> [ServerInterceptor<TunnelUpdate, TunnelUpdate>]

  /// - Returns: Interceptors to use when handling 'reloadTunnels'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeReloadTunnelsInterceptors() -> [ServerInterceptor<Empty, Empty>]

  /// - Returns: Interceptors to use when handling 'reloadNodes'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeReloadNodesInterceptors() -> [ServerInterceptor<Empty, Empty>]

  /// - Returns: Interceptors to use when handling 'clearLog'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeClearLogInterceptors() -> [ServerInterceptor<Empty, Empty>]

  /// - Returns: Interceptors to use when handling 'shutdown'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeShutdownInterceptors() -> [ServerInterceptor<Empty, Empty>]

  /// - Returns: Interceptors to use when handling 'checkUpdate'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeCheckUpdateInterceptors() -> [ServerInterceptor<Empty, SoftwareUpdate>]

  /// - Returns: Interceptors to use when handling 'confirmUpdate'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeConfirmUpdateInterceptors() -> [ServerInterceptor<Empty, Empty>]

  /// - Returns: Interceptors to use when handling 'updateConfig'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeUpdateConfigInterceptors() -> [ServerInterceptor<ServiceConfig, Empty>]

  /// - Returns: Interceptors to use when handling 'openCWD'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeOpenCWDInterceptors() -> [ServerInterceptor<Empty, Empty>]
}

internal enum NatfrpServiceServerMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "NatfrpService",
    fullName: "NatfrpService",
    methods: [
      NatfrpServiceServerMetadata.Methods.streamLog,
      NatfrpServiceServerMetadata.Methods.streamTunnels,
      NatfrpServiceServerMetadata.Methods.streamUpdate,
      NatfrpServiceServerMetadata.Methods.streamStats,
      NatfrpServiceServerMetadata.Methods.login,
      NatfrpServiceServerMetadata.Methods.logout,
      NatfrpServiceServerMetadata.Methods.updateTunnel,
      NatfrpServiceServerMetadata.Methods.reloadTunnels,
      NatfrpServiceServerMetadata.Methods.reloadNodes,
      NatfrpServiceServerMetadata.Methods.clearLog,
      NatfrpServiceServerMetadata.Methods.shutdown,
      NatfrpServiceServerMetadata.Methods.checkUpdate,
      NatfrpServiceServerMetadata.Methods.confirmUpdate,
      NatfrpServiceServerMetadata.Methods.updateConfig,
      NatfrpServiceServerMetadata.Methods.openCWD,
    ]
  )

  internal enum Methods {
    internal static let streamLog = GRPCMethodDescriptor(
      name: "StreamLog",
      path: "/NatfrpService/StreamLog",
      type: GRPCCallType.serverStreaming
    )

    internal static let streamTunnels = GRPCMethodDescriptor(
      name: "StreamTunnels",
      path: "/NatfrpService/StreamTunnels",
      type: GRPCCallType.serverStreaming
    )

    internal static let streamUpdate = GRPCMethodDescriptor(
      name: "StreamUpdate",
      path: "/NatfrpService/StreamUpdate",
      type: GRPCCallType.serverStreaming
    )

    internal static let streamStats = GRPCMethodDescriptor(
      name: "StreamStats",
      path: "/NatfrpService/StreamStats",
      type: GRPCCallType.serverStreaming
    )

    internal static let login = GRPCMethodDescriptor(
      name: "Login",
      path: "/NatfrpService/Login",
      type: GRPCCallType.unary
    )

    internal static let logout = GRPCMethodDescriptor(
      name: "Logout",
      path: "/NatfrpService/Logout",
      type: GRPCCallType.unary
    )

    internal static let updateTunnel = GRPCMethodDescriptor(
      name: "UpdateTunnel",
      path: "/NatfrpService/UpdateTunnel",
      type: GRPCCallType.unary
    )

    internal static let reloadTunnels = GRPCMethodDescriptor(
      name: "ReloadTunnels",
      path: "/NatfrpService/ReloadTunnels",
      type: GRPCCallType.unary
    )

    internal static let reloadNodes = GRPCMethodDescriptor(
      name: "ReloadNodes",
      path: "/NatfrpService/ReloadNodes",
      type: GRPCCallType.unary
    )

    internal static let clearLog = GRPCMethodDescriptor(
      name: "ClearLog",
      path: "/NatfrpService/ClearLog",
      type: GRPCCallType.unary
    )

    internal static let shutdown = GRPCMethodDescriptor(
      name: "Shutdown",
      path: "/NatfrpService/Shutdown",
      type: GRPCCallType.unary
    )

    internal static let checkUpdate = GRPCMethodDescriptor(
      name: "CheckUpdate",
      path: "/NatfrpService/CheckUpdate",
      type: GRPCCallType.unary
    )

    internal static let confirmUpdate = GRPCMethodDescriptor(
      name: "ConfirmUpdate",
      path: "/NatfrpService/ConfirmUpdate",
      type: GRPCCallType.unary
    )

    internal static let updateConfig = GRPCMethodDescriptor(
      name: "UpdateConfig",
      path: "/NatfrpService/UpdateConfig",
      type: GRPCCallType.unary
    )

    internal static let openCWD = GRPCMethodDescriptor(
      name: "OpenCWD",
      path: "/NatfrpService/OpenCWD",
      type: GRPCCallType.unary
    )
  }
}
